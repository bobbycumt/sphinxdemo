# 操作及注意事项

## codeblocks

- F9运行
- F2调出报错信息
- 建立一个项目，再建立四个程序文件，不要加入项目，保存到相应的位置，项目单独放在一个地方

## 骗分

- P1125
- P7911
- P9752
- P7071

## 测评软件

- 一步一保存
- 在players新建day1文件夹，然后把程序文件夹复制过去
- Evaluate文件夹放测试数据，文件名加上测试点序号，.in为测试点，.ans为输出结果

## 编程注意

- x，y开头变量不能用，与函数库冲突
- Long long 对应%lld
- 变量不超范围，但是计算的中间过程超了范围
- 遇到编译错误，且不知道是哪的错：全注释，编译，一行一行解注释，解一行编译一行
- 使用二维数组要谨慎，整型二维数组不超过100*100

  ```c++
  int a[10000][10000];//可以算出占用空间400M，MLE
  ```

- 除了高精度以外，常规方法不能满分，需要找另外的方法解决，一定有另外的方法

- 循环10^9会超时

- 循环内部需要确认哪些变量需要在每次循环时初始化，在什么位置初始化，在多组数据的题目中尤其要注意，比如记录状态的数组、状态变量等

- 需要记录元素的值和编号，优先考虑结构体数组，包含两个成员：值和id，这样在排序后能记录原始位置

- 统计每个元素出现的次数，优先考虑计数排序，但要注意每个元素的值范围，如果值到达整型最大值，不能使用计数排序，考虑别的方法实现

- 再三确认数据范围及特殊性质，有时程序在某个范围内能拿到部分分数，但是扩展到全范围就会超时或0分，如果不能实现全范围数据，就要调整策略，让程序只满足部分数据

  
---
## C++ 常用的数学函数

| 函数名         | 功能说明                      | 示例                   |
|----------------|------------------------------|------------------------|
| abs(x)         | 取绝对值（整型/浮点型）      | abs(-5) → 5           |
| fabs(x)        | 取绝对值（浮点型）           | fabs(-3.14) → 3.14    |
| sqrt(x)        | 开平方根                     | sqrt(9) → 3           |
| pow(x, y)      | 幂运算，x 的 y 次方          | pow(2, 3) → 8         |
| ceil(x)        | 向上取整                     | ceil(2.3) → 3         |
| floor(x)       | 向下取整                     | floor(2.7) → 2        |
| round(x)       | 四舍五入                     | round(2.5) → 3        |
| max(a, b)      | 取较大值 | max(3, 5) → 5         |
| min(a, b)      | 取较小值 | min(3, 5) → 3         |
| __gcd(a, b)      | 取最大公约数 | __gcd(18, 12) → 6         |

**注意：**  
- `abs` 既可用于整型也可用于浮点型，但推荐浮点用 `fabs`。
---
## C++ 常用的字符函数

| 函数名         | 功能说明                   | 示例                  |
|----------------|---------------------------|-----------------------|
| isalpha(c)     | 判断是否字母              | isalpha('A') → 1     |
| isdigit(c)     | 判断是否数字              | isdigit('3') → 1     |
| islower(c)     | 判断是否小写字母          | islower('a') → 1     |
| isupper(c)     | 判断是否大写字母          | isupper('A') → 1     |
| tolower(c)     | 转换为小写字母            | tolower('A') → 'a'   |
| toupper(c)     | 转换为大写字母            | toupper('a') → 'A'   |

**注意：**  
- 这些函数参数和返回值均为 `int`，但通常传入 `char` 类型即可。
- 需包含头文件 `<cctype>`。
---
## C++ `string` 常用函数如下

| 函数名/方法             | 功能说明                          | 示例                                      |
|------------------------|-----------------------------------|-------------------------------------------|
| s.length() / s.size()  | 返回字符串长度                     | s.length()                                |
| s.empty()              | 判断字符串是否为空                 | s.empty()                                 |
| s.clear()              | 清空字符串                         | s.clear()                                 |
| s[i]                   | 访问第 i 个字符（下标从 0 开始）   | s[0]                                      |
| s.substr(pos, len)     | 返回从 pos 开始的 len 个字符子串   | s.substr(1, 3)                            |                      |
| s.insert(pos, str)     | 在 pos 位置插入字符串 str          | s.insert(2, "xy")                         |
| s.erase(pos, len)      | 删除从 pos 开始的 len 个字符       | s.erase(1, 2)                             |
| s.replace(pos, len, t) | 替换从 pos 开始的 len 个字符为 t   | s.replace(0, 2, "hi")                     |
| s.append(str)          | 在末尾追加字符串                   | s.append("xyz")                           |
| s.push_back(c)         | 在末尾追加字符                     | s.push_back('a')                          |
| s.pop_back()           | 删除末尾字符                       | s.pop_back()                              |
| s.compare(str)         | 比较字符串大小                     | s.compare("abc")                          |
| getline(cin, s)        | 从输入流读取一整行到字符串         | getline(cin, s)                           |
| s.c_str()              | 转为 C 风格字符串（const char*）   | printf("%s", s.c_str())                   |

**注意：**
- 这些方法适用于 `std::string` 类型。
- 需包含头文件 `<string>`。
---
## 二分查找函数
C++ 常用的二分查找函数有 `lower_bound` 和 `upper_bound`，都在 `<algorithm>` 头文件中，适用于**有序区间**。

---

### 1. `lower_bound`

- 用法：查找**第一个大于等于**目标值的位置
- 返回值：迭代器（如数组指针或 vector 的 iterator）

```cpp
#include <algorithm>
int arr[] = {1, 3, 5, 7, 9};
cout<<lower_bound(arr, arr + 5, 5)-arr; // 指向 arr[2]，即5，此输出结果为2
cout<<arr[lower_bound(arr, arr + 5, 5)-arr]; //输出5

```

---

### 2. `upper_bound`

- 用法：查找**第一个大于**目标值的位置
- 返回值：迭代器

```cpp
#include <algorithm>
int arr[] = {1, 3, 5, 7, 9};
cout<<upper_bound(arr, arr + 5, 5)-arr; // 指向 arr[3]，即7，此输出结果为3
cout<<arr[upper_bound(arr, arr + 5, 5)-arr]; //输出7
```
---

### 3. 注意事项

- 只能用于**有序数组或容器**。
- 返回的是**迭代器**，如需下标可用 `pos - arr`。

---
## 全排列函数
C++ 全排列常用函数是 `next_permutation` 和 `prev_permutation`，在 `<algorithm>` 头文件中。

---

### 用法示例

```cpp
#include <algorithm>
#include <iostream>
using namespace std;

int main() {
    int arr[] = {1, 2, 3};
    sort(arr, arr + 3); // 必须先排序
    do {
        for (int i = 0; i < 3; ++i)
            cout << arr[i] << " ";
        cout << endl;
    } while (next_permutation(arr, arr + 3));
    return 0;
}
```

---

### 说明

- `next_permutation(begin, end)`  
  生成**字典序下一个排列**，返回 `true` 表示有下一个排列，`false` 表示已到最后一个排列。
- `prev_permutation(begin, end)`  
  生成**字典序上一个排列**。

---

### 注意事项

- 使用前通常要先排序，保证从最小排列开始。
- 适用于数组、vector、string 等容器。
- 如需生成所有排列，通常配合 `do...while` 循环使用。
---
## 四舍五入到整十位、整百位

`(a+5)/10*10`

`(a+50)/100*100`

---
# P11228 [CSP-J 2024] 地图探险

## 题目描述

小 A 打算前往一片丛林去探险。丛林的地理环境十分复杂，为了防止迷路，他先派遣了一个机器人前去探路。

丛林的地图可以用一个 \\(n)\\ 行 $m$ 列的字符表来表示。我们将第 $i$ 行第 $j$ 列的位置的坐标记作 $(i, j)(1 \leq i \leq n$，$1 \leq j \leq m)$。如果这个位置的字符为 $\tt x$，即代表这个位置上有障碍，不可通过。反之，若这个位置的字符为 $\tt.$，即代表这个位置是一片空地，可以通过。

这个机器人的状态由位置和朝向两部分组成。其中位置由坐标 $(x, y)(1 \leq x \leq n$，$1 \leq y \leq m)$ 刻画，它表示机器人处在地图上第 $x$ 行第 $y$ 列的位置。而朝向用一个 $0 \sim 3$ 的整数 $d$ 表示，其中 $d = 0$ 代表向东，$d = 1$ 代表向南，$d = 2$ 代表向西，$d = 3$ 代表向北。

初始时，机器人的位置为 $(x_0, y_0)$，朝向为 $d_0$。**保证初始时机器人所在的位置为空地**。接下来机器人将要进行 $k$ 次操作。每一步，机器人将按照如下的模式操作：

1. 假设机器人当前处在的位置为 $(x, y)$，朝向为 $d$。则它的方向上的下一步的位置 $(x^′, y^′)$ 定义如下：若 $d = 0$，则令 $(x^′, y^′) = (x, y + 1)$，若 $d = 1$，则令 $(x^′, y^′) = (x + 1, y)$，若 $d = 2$，则令 $(x^′, y^′) = (x, y - 1)$，若 $d = 3$，则令 $(x^′, y^′) = (x - 1, y)$。

2. 接下来，机器人判断它下一步的位置是否在地图内，且是否为空地。具体地说，它判断 $(x^′, y^′)$ 是否满足 $1 \leq x^′ \leq n, 1 \leq y^′ \leq m$，且 $(x^′, y^′)$ 位置上是空地。如果条件成立，则机器人会向前走一步。它新的位置变为 $(x^′, y^′)$，且朝向不变。如果条件不成立，则它会执行“向右转”操作。也就是说，令 $d^′ = (d + 1) \bmod 4$（即 $d + 1$ 除以 $4$ 的余数），且它所处的位置保持不变，但朝向由 $d$ 变为 $d^′$。

小 A 想要知道，在机器人执行完 $k$ 步操作之后，地图上所有被机器人经过的位置（包括起始位置）有几个。

## 输入格式

**本题有多组测试数据。**

输入的第一行包含一个正整数 $T$，表示数据组数。

接下来包含 $T$ 组数据，每组数据的格式如下：

第一行包含三个正整数 $n, m, k$。其中 $n, m$ 表示地图的行数和列数，$k$ 表示机器人执行操作的次数。

第二行包含两个正整数 $x_0, y_0$ 和一个非负整数 $d_0$。

接下来 $n$ 行，每行包含一个长度为 $m$ 的字符串。保证字符串中只包含 $\tt{x}$ 和 $\tt{.}$ 两个字符。其中，第 $x$ 行的字符串的第 $y$ 个字符代表的位置为 $(x, y)$。这个位置是 $\tt{x}$ 即代表它是障碍，否则代表它是空地。数据保证机器人初始时所在的位置为空地。

## 输出格式

对于每组数据：输出一行包含一个正整数，表示地图上所有被机器人经过的位置（包括起始位置）的个数。

## 输入输出样例 #1

### 输入 #1

```
2
1 5 4
1 1 2
....x
5 5 20
1 1 0
.....
.xxx.
.x.x.
..xx.
x....
```

### 输出 #1

```
3
13
```

## 说明/提示

**【样例 1 解释】**

该样例包含两组数据。对第一组数据，机器人的状态以如下方式变化：
1. 初始时，机器人位于位置 $(1, 1)$，方向朝西（用数字 $2$ 代表）。
2. 第一步，机器人发现它下一步的位置 $(1, 0)$ 不在地图内，因此，它会执行“向右转”操作。此时，它的位置仍然为 $(1, 1)$，但方向朝北（用数字 $3$ 代表）。
3. 第二步，机器人发现它下一步的位置 $(0, 1)$ 不在地图内，因此，它仍然会执行“向右转”操作。此时，它的位置仍然为 $(1, 1)$，但方向朝东（用数字 $0$ 代表）。
4. 第三步，机器人发现它下一步的位置 $(1, 2)$ 在地图内，且为空地。因此，它会向东走一步。此时，它的位置变为 $(1, 2)$，方向仍然朝东。
5. 第四步，机器人发现它下一步的位置 $(1, 3)$ 在地图内，且为空地。因此，它会向东走一步。此时，它的位置变为 $(1, 3)$，方向仍然朝东。

因此，四步之后，机器人经过的位置有三个，分别为 $(1, 1),(1, 2),(1, 3)$。

对第二组数据，机器人依次执行的操作指令为：向东走到 $(1, 2)$，向东走到 $(1, 3)$，向东走到 $(1, 4)$，向东走到 $(1, 5)$，向右转，向南走到 $(2, 5)$，向南走到 $(3, 5)$，向南走到 $(4, 5)$，向南走到 $(5, 5)$，向右转，向西走到 $(5, 4)$，向西走到 $(5, 3)$，向西走到 $(5, 2)$，向右转，向北走到 $(4, 2)$，向右转，向右转，向南走到 $(5, 2)$，向右转，向右转。

**【样例 2】**

见选手目录下的 explore/explore2.in 与 explore/explore2.ans。

该样例满足第 $3\sim 4$ 个测试点的限制条件。

**【样例 3】**

见选手目录下的 explore/explore3.in 与 explore/explore3.ans。

该样例满足第 $5$ 个测试点的限制条件。

**【样例 4】**

见选手目录下的 explore/explore4.in 与 explore/explore4.ans。

该样例满足第 $6$ 个测试点的限制条件。

**【样例 5】**

见选手目录下的 explore/explore5.in 与 explore/explore5.ans。

该样例满足第 $8 \sim 10$ 个测试点的限制条件。

**【数据范围】**

对于所有测试数据，保证：$1 \leq T \leq 5$，$1 \leq n, m \leq 10^3$，$1 \leq k \leq 10^6$，$1 \leq x_0 \leq n$，$1 \leq y_0 \leq m$，$0 \leq d_0 \leq 3$，且机器人的起始位置为空地。

| 测试点编号 | $n$ | $m$ | $k$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $=1$ | $\leq 2$ | $=1$ | 无 |
| $2$ | $=1$ | $\leq 2$ | $=1$ | 无 |
| $3$ | $\leq 10^2$ | $\leq 10^2$ | $=1$ | 无 |
| $4$ | $\leq 10^2$ | $\leq 10^2$ | $=1$ | 无 |
| $5$ | $=1$ | $\leq 10^3$ | $\leq 2\times 10^3$ | 地图上所有位置均为空地 |
| $6$ | $=1$ | $\leq 10^3$ | $\leq 2\times 10^3$ | 无|
| $7$ | $\leq 10^3$ | $\leq 10^3$ | $\leq 10^6$ |  地图上所有位置均为空地 |
| $8$ | $\leq 10^3$ | $\leq 10^3$ | $\leq 10^6$ | 无 |
| $9$ | $\leq 10^3$ | $\leq 10^3$ | $\leq 10^6$ | 无 |
| $10$ | $\leq 10^3$ | $\leq 10^3$ | $\leq 10^6$ | 无 |

## 🧠 一、暴力模拟思路（本题本身即需暴力）

题目本质是 **直接模拟移动条件**，逐步执行机器人在地图上的运动情况：

1. 读取起始位置 $(x, y)$、朝向 $d$、步数 $k$ ；
2. 用方向数组 `dx, dy` 表示东南西北四个方向；
3. 循环执行 $k$ 步：

   * 计算下一个位置 $(x+dx[d], y+dy[d])$；
   * 如果该位置在地图内且是空地（`.`），则移动至该位置，并记录是否首次访问；
   * 否则原地旋转：方向 $d = (d + 1) \% 4$；
4. 最后统计所有访问过的位置总数。

**注意细节**：

* 每次转向也算一步（即步数 $k$ 无论是移动还是转向都会消耗）；
* 起始位置计入访问总数；
* 多组测试务必在每组前清空 `vis` 数组。

该模拟对最大 $k\le 10^6$、$n,m\le 1000$ 均可在时间限制内直接 AC，是题目的标准解法，也可视为“暴力枚举”。

---

## ✅ 二、标准 C++ 模板代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1005;
char mp[MAXN][MAXN];
bool vis[MAXN][MAXN];
const int dx[4] = {0, 1, 0, -1};  // 东、南、西、北
const int dy[4] = {1, 0, -1, 0};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    while (T--) {
        int n, m;
        long long k;
        int x, y, d;
        cin >> n >> m >> k;
        cin >> x >> y >> d;

        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                cin >> mp[i][j];
                vis[i][j] = false;
            }
        }

        long long ans = 0;
        vis[x][y] = true;
        ans++;

        while (k--) {
            int nx = x + dx[d];
            int ny = y + dy[d];
            if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && mp[nx][ny] == '.') {
                x = nx;
                y = ny;
                if (!vis[x][y]) {
                    vis[x][y] = true;
                    ans++;
                }
            } else {
                d = (d + 1) % 4;
            }
        }

        cout << ans << "\n";
    }

    return 0;
}
```

---

## 🔍 三、模板说明

* **输入输出格式**：支持多组数据 $T$，每组读入地图尺寸、起始状态与地图内容；
* **方向移动控制**：利用四向数组 `dx, dy` 实现移动或旋转；
* **可视为暴力枚举模板**：按题意模拟每步操作，时空复杂度为 $O(T \cdot k)$，符合 CSP-J 要求；
* **保证输出正确性**：先清 `vis`，走过格子累加 `ans`，起点默认计入。

---

## ✅ 四、总结

* 本题本质就是“暴力模拟题”，在复赛中只用暴力法便能稳拿满分；
* 关键点在于：每一步操作都真实模拟、注意边界、清空状态；
