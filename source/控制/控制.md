

## if：条件

通过if指令，用户可以让Arduino判断某一个条件是否达到，并且根据这一判断结果执行相应的程序。

![if语句结构图](http://www.taichi-maker.com/wp-content/uploads/2016/04/if-statement.gif)

```C++
if( a == 0 ) 
{
	digitalWrite(LEDpin, HIGH);
}
```

在以上示例中，Arduino控制器通过判断变量a是否等于0，从而决定是否执行指令`digitalWrite(LEDpin, HIGH);`
假如变量a确实等于0，则执行这条指令。否则Arduino将不执行这条指令。

**注意：在以上示例的表达式`a == 0`中，`==`是关系运算符号，这条语句的作用是让Arduino判断变量a是否等于零。切记不能使用单一等号`=`。`=`是赋值符号。` a = 0 `的含义是给变量a赋值0。**

------

## if…else：如果...否则

![if...else语句结构](http://www.taichi-maker.com/wp-content/uploads/2016/04/if-else.gif)

上述结构表示:如果 “表达式1” 的条件得到满足则执行”语句块1″。否则Arduino将执行”语句块2″。

```C++
if( a == 0 ) 
{
    digitalWrite(LEDpin, HIGH);
}
else 
{
    digitalWrite(LEDpin, LOW);
}
```

在以上示例中，Arduino控制器通过判断变量a是否等于0，从而决定是否执行指令（点亮LED）`digitalWrite(LEDpin, HIGH);`
假如变量a确实等于0，则执行这条指令。否则Arduino将不执行指令：(保持LED熄灭）`digitalWrite(LEDpin, LOW);`

------

## for：for循环

for语句用于重复执行一段语句块。通常会使用一个增量计数器递增和终止循环。

```C++
void loop() 
{
   for (int i=0; i <= 255; i++)
   {  //开始运行for循环语句
      analogWrite(9, i);     //对引脚9写入i的数值
      delay(10);                  //延迟10毫秒
   } 
}
```

Arduino运行以上程序后，连接在引脚9上的LED将产生由暗到明的反复变化。

当程序运行到for语句时，首先Arduino将数值0赋值给变量i。接着Arduino将判断i是否满足小于255这一条件。由于此时i = 0，所以 i<=255这一条件为真。于是程序将执行花括号中的程序。

当执行完花括号中的程序后，Arduino将返回到for语句后面括号中的最后一个表达式i++，对i执行加1的操作。执行完这一步后，Arduino再次判断i<=255这一条件是否为真。由于此时i = 1, 即i依然小于255，所以Arduino将再一次执行花括号中的语句块。依此重复循环直到i的数值递增到256时，i不再小于等于255（即 i < = 255这一表达式为假）。这时候Arduino将结束循环执行for语句后面花括号中的程序块。

------

## while：while循环

while循环将会连续地无限地循环，直到圆括号（）中的表达式变为假。被测试的表达式变量必须被改变，否则while循环将永远不会中止。

```C++
void setup() 
{
    // 初始化串口通讯
    Serial.begin(9600);
}
 
void loop() 
{
    int i=1, sum=0;
    while(i<=100)
    {   //判断i是否小于等于零
        sum+=i;  //当i小于等于零时，
        i++;     //执行循环体中的语句。
    }
    Serial.print ("sum = ");  //通过串口监视器输出
    Serial.println (sum);     //while循环结束后的sum值
    
    delay (5000); // 延迟5秒钟    
}
```

1) 程序运行到while语句时，因为 i=1，所以i<=100 为真，于是Arduino将执行循环体（以上示例程序中第22行和第23行语句）；执行结束后 i 的值变为 2，sum 的值变为 1。
2) 接下来Arduino会继续判断 i=100 是否成立，因为此时 i=2，i<=100 成立，所以继续执行循环体；执行结束后 i 的值变为 3，sum 的值变为3。
3) 重复执行步骤 2)。
4) 当循环进行到第100次，i 的值变为 101，sum 的值变为5050；因为此时 i<=100 不再成立，所以Arduino将出循环，不再执行循环体，转而执行while循环后面的代码，延迟五秒钟。

------

## delay()：毫秒延时

delay()函数可用于暂停程序运行。暂停时间可以由delay()函数的参数进行控制，单位是毫秒（1秒钟＝1000毫秒）。

### 示例

```C++
void loop()
{
  digitalWrite(ledPin, HIGH);   // 点亮LED
  delay(1000);                  // 等待一秒钟（1000毫秒）
  digitalWrite(ledPin, LOW);    // 熄灭LED
  delay(1000);                  // 等待一秒钟（1000毫秒）
}
```

------

## delayMicroseconds()：微秒延时

delayMicroseconds()与[delay()](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/delay/)函数都可用于暂停程序运行。不同的是，delayMicroseconds()的参数单位是微秒（1毫秒＝1000微秒）。

------

## millis()：获取Arduino开机后运行的时间

millis函数可以用来获取Arduino开机后运行的时间长度，该时间长度单位是毫秒,最长可记录接近50天左右的时间。如果超出记录时间上限，记录将从0重新开始。

### 返回值

Arduino开机后运行的时间长度，此时间数值以毫秒为单位（返回值类型：[无符号长整型](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/unsigned-long/)）

### 注意：

millis函数的返回值为[无符号长整型](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/unsigned-long/)数据, 如果将该数值与整型数据或其它数据类型进行运算，运行结果将产生错误。

### 示例程序-1

以下实例程序将通过串口监视器输出程序的运行时间

```C++
unsigned long time;
 
void setup(){
  Serial.begin(9600);
}
void loop(){
  Serial.print("Arduino has been running this sketch for ");
  time = millis();
  //输出程序运行时间
  Serial.print(time);
  Serial.println(" milliseconds.");
  delay(1000);
}
```

### 示例程序-2

```C++
/* 
 *  millisBlink
 * 本示例程序使用millis()函数控制Arduino开发板内置LED的点亮和熄灭。
*/
unsigned long previousBlinkTime;
int blinkInterval = 1000; //LED闪烁时间间隔
bool toggle;
 
void setup() {
  pinMode(LED_BUILTIN, OUTPUT); 
  Serial.begin(9600);
}
 
void loop() {  
  unsigned long currentMillis = millis(); // 获取当前时间
  millisBlink(currentMillis);
 
  /* 由于使用millis()函数控制LED闪烁，所以loop函数中没有delay。
   * 于是我们可以在loop函数中流畅的执行其他操作。
  */
 
}
 
void millisBlink(unsigned long currentTime) { 
  //检查是否到达时间间隔
  if (currentTime - previousBlinkTime >= blinkInterval) {    //如果时间间隔达到了
    toggle = (toggle == 1) ? 0 : 1;    
    digitalWrite(LED_BUILTIN, toggle);                       //执行闪烁LED操作
    
    previousBlinkTime = currentTime;  // 将检查时间复位   
    
    Serial.print(F("toggle = "));Serial.println(toggle);          
  }  else if (currentTime - previousBlinkTime <= 0) {   // 如果millis时间溢出
    previousBlinkTime = currentTime;
  }
}
```

